{"version":3,"file":"index.js","mappings":"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","sources":["webpack://CKEditor/webpack/universalModuleDefinition","webpack://CKEditor/external umd \"@ckeditor/ckeditor5-watchdog\"","webpack://CKEditor/external umd \"prop-types\"","webpack://CKEditor/external umd \"react\"","webpack://CKEditor/webpack/bootstrap","webpack://CKEditor/webpack/runtime/compat get default export","webpack://CKEditor/webpack/runtime/define property getters","webpack://CKEditor/webpack/runtime/hasOwnProperty shorthand","webpack://CKEditor/webpack/runtime/make namespace object","webpack://CKEditor/./node_modules/@ckeditor/ckeditor5-utils/src/uid.js","webpack://CKEditor/./src/ckeditorcontext.tsx","webpack://CKEditor/./src/ckeditor.tsx","webpack://CKEditor/./src/useMultiRootEditor.tsx"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"), require(\"prop-types\"), require(\"@ckeditor/ckeditor5-watchdog\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\", \"prop-types\", \"@ckeditor/ckeditor5-watchdog\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"CKEditor\"] = factory(require(\"react\"), require(\"prop-types\"), require(\"@ckeditor/ckeditor5-watchdog\"));\n\telse\n\t\troot[\"CKEditor\"] = factory(root[\"react\"], root[\"prop-types\"], root[\"@ckeditor/ckeditor5-watchdog\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__155__, __WEBPACK_EXTERNAL_MODULE__949__, __WEBPACK_EXTERNAL_MODULE__546__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__546__;","module.exports = __WEBPACK_EXTERNAL_MODULE__949__;","module.exports = __WEBPACK_EXTERNAL_MODULE__155__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module utils/uid\n */\n/**\n * A hash table of hex numbers to avoid using toString() in uid() which is costly.\n * [ '00', '01', '02', ..., 'fe', 'ff' ]\n */\nconst HEX_NUMBERS = new Array(256).fill('')\n    .map((_, index) => ('0' + (index).toString(16)).slice(-2));\n/**\n * Returns a unique id. The id starts with an \"e\" character and a randomly generated string of\n * 32 alphanumeric characters.\n *\n * **Note**: The characters the unique id is built from correspond to the hex number notation\n * (from \"0\" to \"9\", from \"a\" to \"f\"). In other words, each id corresponds to an \"e\" followed\n * by 16 8-bit numbers next to each other.\n *\n * @returns An unique id string.\n */\nexport default function uid() {\n    // Let's create some positive random 32bit integers first.\n    //\n    // 1. Math.random() is a float between 0 and 1.\n    // 2. 0x100000000 is 2^32 = 4294967296.\n    // 3. >>> 0 enforces integer (in JS all numbers are floating point).\n    //\n    // For instance:\n    //\t\tMath.random() * 0x100000000 = 3366450031.853859\n    // but\n    //\t\tMath.random() * 0x100000000 >>> 0 = 3366450031.\n    const r1 = Math.random() * 0x100000000 >>> 0;\n    const r2 = Math.random() * 0x100000000 >>> 0;\n    const r3 = Math.random() * 0x100000000 >>> 0;\n    const r4 = Math.random() * 0x100000000 >>> 0;\n    // Make sure that id does not start with number.\n    return 'e' +\n        HEX_NUMBERS[r1 >> 0 & 0xFF] +\n        HEX_NUMBERS[r1 >> 8 & 0xFF] +\n        HEX_NUMBERS[r1 >> 16 & 0xFF] +\n        HEX_NUMBERS[r1 >> 24 & 0xFF] +\n        HEX_NUMBERS[r2 >> 0 & 0xFF] +\n        HEX_NUMBERS[r2 >> 8 & 0xFF] +\n        HEX_NUMBERS[r2 >> 16 & 0xFF] +\n        HEX_NUMBERS[r2 >> 24 & 0xFF] +\n        HEX_NUMBERS[r3 >> 0 & 0xFF] +\n        HEX_NUMBERS[r3 >> 8 & 0xFF] +\n        HEX_NUMBERS[r3 >> 16 & 0xFF] +\n        HEX_NUMBERS[r3 >> 24 & 0xFF] +\n        HEX_NUMBERS[r4 >> 0 & 0xFF] +\n        HEX_NUMBERS[r4 >> 8 & 0xFF] +\n        HEX_NUMBERS[r4 >> 16 & 0xFF] +\n        HEX_NUMBERS[r4 >> 24 & 0xFF];\n}\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport React, { type ReactNode } from 'react';\nimport PropTypes, { type InferProps, type Validator } from 'prop-types';\n\nimport { ContextWatchdog } from '@ckeditor/ckeditor5-watchdog';\nimport type { WatchdogConfig } from '@ckeditor/ckeditor5-watchdog/src/watchdog';\n\nimport type { Context, ContextConfig } from '@ckeditor/ckeditor5-core';\n\nexport const ContextWatchdogContext = React.createContext<ContextWatchdog | 'contextWatchdog' | null>( 'contextWatchdog' );\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport default class CKEditorContext<TContext extends Context = Context> extends React.Component<Props<TContext>, {}> {\n\tpublic contextWatchdog: ContextWatchdog<TContext> | null = null;\n\n\tconstructor( props: Props<TContext>, context: any ) {\n\t\tsuper( props, context );\n\n\t\tif ( this.props.isLayoutReady ) {\n\t\t\tthis._initializeContextWatchdog( this.props.config );\n\t\t}\n\t}\n\n\tpublic override shouldComponentUpdate( nextProps: Readonly<Props<TContext> & { children?: ReactNode | undefined }> ): boolean {\n\t\treturn this._shouldComponentUpdate( nextProps ) as unknown as boolean;\n\t}\n\n\t/**\n\t * Wrapper for the async handler. Note that this is an implementation bug, see https://github.com/ckeditor/ckeditor5-react/issues/312.\n\t */\n\tprivate async _shouldComponentUpdate( nextProps: Readonly<Props<TContext> & { children?: ReactNode | undefined }> ): Promise<boolean> {\n\t\t// If the configuration changes then the ContextWatchdog needs to be destroyed and recreated\n\t\t// On top of the new configuration.\n\t\tif ( nextProps.id !== this.props.id ) {\n\t\t\t/* istanbul ignore else */\n\t\t\tif ( this.contextWatchdog ) {\n\t\t\t\tawait this.contextWatchdog.destroy();\n\t\t\t}\n\n\t\t\tawait this._initializeContextWatchdog( nextProps.config );\n\t\t}\n\n\t\tif ( nextProps.isLayoutReady && !this.contextWatchdog ) {\n\t\t\tawait this._initializeContextWatchdog( nextProps.config );\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// Rerender the component only when children has changed.\n\t\treturn this.props.children !== nextProps.children;\n\t}\n\n\tpublic override render(): ReactNode {\n\t\treturn (\n\t\t\t<ContextWatchdogContext.Provider value={ this.contextWatchdog }>\n\t\t\t\t{ this.props.children }\n\t\t\t</ContextWatchdogContext.Provider>\n\t\t);\n\t}\n\n\tpublic override componentWillUnmount(): void {\n\t\tthis._destroyContext();\n\t}\n\n\tprivate async _initializeContextWatchdog( config?: ContextConfig ): Promise<void> {\n\t\tthis.contextWatchdog = new ContextWatchdog( this.props.context!, this.props.watchdogConfig );\n\n\t\tthis.contextWatchdog.on( 'error', ( _, errorEvent ) => {\n\t\t\tthis.props.onError( errorEvent.error, {\n\t\t\t\tphase: 'runtime',\n\t\t\t\twillContextRestart: errorEvent.causesRestart\n\t\t\t} );\n\t\t} );\n\n\t\tthis.contextWatchdog.on( 'stateChange', () => {\n\t\t\tif ( this.contextWatchdog!.state === 'ready' && this.props.onReady ) {\n\t\t\t\tthis.props.onReady( this.contextWatchdog!.context! );\n\t\t\t}\n\t\t} );\n\n\t\tawait this.contextWatchdog.create( config )\n\t\t\t.catch( error => {\n\t\t\t\tthis.props.onError( error, {\n\t\t\t\t\tphase: 'initialization',\n\t\t\t\t\twillContextRestart: false\n\t\t\t\t} );\n\t\t\t} );\n\t}\n\n\tprivate async _destroyContext(): Promise<void> {\n\t\tif ( this.contextWatchdog ) {\n\t\t\tawait this.contextWatchdog.destroy();\n\t\t\tthis.contextWatchdog = null;\n\t\t}\n\t}\n\n\tpublic static defaultProps: Partial<Props<Context>> = {\n\t\tisLayoutReady: true,\n\t\tonError: ( error, details ) => console.error( error, details )\n\t};\n\n\tpublic static propTypes = {\n\t\tid: PropTypes.string,\n\t\tisLayoutReady: PropTypes.bool,\n\t\tcontext: PropTypes.func as unknown as Validator<{ create( ...args: any ): Promise<any> } | undefined>,\n\t\twatchdogConfig: PropTypes.object,\n\t\tconfig: PropTypes.object,\n\t\tonReady: PropTypes.func,\n\t\tonError: PropTypes.func\n\t};\n}\n\ninterface Props<TContext extends Context> extends InferProps<typeof CKEditorContext.propTypes> {\n\tcontext?: { create( ...args: any ): Promise<TContext> };\n\twatchdogConfig?: WatchdogConfig;\n\tconfig?: ContextConfig;\n\tonReady?: ( context: Context ) => void; // TODO this should accept TContext (after ContextWatchdog release).\n\tonError: ( error: Error, details: ErrorDetails ) => void;\n\tchildren?: ReactNode;\n}\n\ninterface ErrorDetails {\n\tphase: 'initialization' | 'runtime';\n\twillContextRestart: boolean;\n}\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/* globals window */\n\nimport React from 'react';\nimport PropTypes, { type InferProps, type Validator } from 'prop-types';\n\nimport uid from '@ckeditor/ckeditor5-utils/src/uid';\n\nimport type { EventInfo } from '@ckeditor/ckeditor5-utils';\nimport type { Editor, EditorConfig } from '@ckeditor/ckeditor5-core';\nimport type { DocumentChangeEvent } from '@ckeditor/ckeditor5-engine';\n\nimport { EditorWatchdog, ContextWatchdog } from '@ckeditor/ckeditor5-watchdog';\nimport type { WatchdogConfig } from '@ckeditor/ckeditor5-watchdog/src/watchdog';\nimport type { EditorCreatorFunction } from '@ckeditor/ckeditor5-watchdog/src/editorwatchdog';\n\nimport { ContextWatchdogContext } from './ckeditorcontext';\n\nconst REACT_INTEGRATION_READ_ONLY_LOCK_ID = 'Lock from React integration (@ckeditor/ckeditor5-react)';\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport default class CKEditor<TEditor extends Editor> extends React.Component<Props<TEditor>, {}> {\n\t/**\n\t * Contains a promise that resolves when the editor destruction is finished.\n\t */\n\tprivate editorDestructionInProgress: Promise<void> | null = null;\n\n\t/**\n\t * After mounting the editor, the variable will contain a reference to the created editor.\n\t * @see: https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html\n\t */\n\tprivate domContainer = React.createRef<HTMLDivElement>();\n\n\t/**\n\t * An instance of EditorWatchdog or an instance of EditorWatchdog-like adapter for ContextWatchdog.\n\t * It holds the instance of the editor under `this.watchdog.editor` if `props.disableWatchdog` is set to false.\n\t */\n\tprivate watchdog: EditorWatchdog<TEditor> | EditorWatchdogAdapter<TEditor> | null = null;\n\n\t/**\n\t * Holds the instance of the editor if `props.disableWatchdog` is set to true.\n\t */\n\tprivate instance: Editor | undefined | null;\n\n\tconstructor( props: Props<TEditor> ) {\n\t\tsuper( props );\n\n\t\tconst { CKEDITOR_VERSION } = window;\n\n\t\tif ( CKEDITOR_VERSION ) {\n\t\t\tconst [ major ] = CKEDITOR_VERSION.split( '.' ).map( Number );\n\n\t\t\tif ( major < 37 ) {\n\t\t\t\tconsole.warn( 'The <CKEditor> component requires using CKEditor 5 in version 37 or higher.' );\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.warn( 'Cannot find the \"CKEDITOR_VERSION\" in the \"window\" scope.' );\n\t\t}\n\t}\n\n\t/**\n\t * An editor instance.\n\t */\n\tpublic get editor(): Editor | null {\n\t\tif ( this.props.disableWatchdog ) {\n\t\t\treturn this.instance!;\n\t\t}\n\n\t\tif ( !this.watchdog ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.watchdog.editor;\n\t}\n\n\t/**\n\t * The CKEditor component should not be updated by React itself.\n\t * However, if the component identifier changes, the whole structure should be created once again.\n\t */\n\tpublic override shouldComponentUpdate( nextProps: Readonly<Props<TEditor>> ): boolean {\n\t\tif ( !this.editor ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Only when the component identifier changes the whole structure should be re-created once again.\n\t\tif ( nextProps.id !== this.props.id ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( nextProps.disableWatchdog !== this.props.disableWatchdog ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( this._shouldUpdateEditor( nextProps ) ) {\n\t\t\tthis.editor.data.set( nextProps.data! );\n\t\t}\n\n\t\tif ( 'disabled' in nextProps ) {\n\t\t\tif ( nextProps.disabled ) {\n\t\t\t\tthis.editor.enableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t} else {\n\t\t\t\tthis.editor.disableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Initialize the editor when the component is mounted.\n\t */\n\tpublic override async componentDidMount(): Promise<void> {\n\t\tawait this._initializeEditor();\n\t}\n\n\t/**\n\t * Re-render the entire component once again. The old editor will be destroyed and the new one will be created.\n\t */\n\tpublic override async componentDidUpdate(): Promise<void> {\n\t\tawait this._destroyEditor();\n\t\tawait this._initializeEditor();\n\t}\n\n\t/**\n\t * Destroy the editor before unmounting the component.\n\t */\n\tpublic override async componentWillUnmount(): Promise<void> {\n\t\tawait this._destroyEditor();\n\t}\n\n\t/**\n\t * Render a <div> element which will be replaced by CKEditor.\n\t */\n\tpublic override render(): React.ReactNode {\n\t\treturn (\n\t\t\t<div ref={ this.domContainer }></div>\n\t\t);\n\t}\n\n\t/**\n\t * Initializes the editor by creating a proper watchdog and initializing it with the editor's configuration.\n\t */\n\tprivate async _initializeEditor(): Promise<unknown> {\n\t\tawait this.editorDestructionInProgress;\n\n\t\tif ( this.props.disableWatchdog ) {\n\t\t\tthis.instance = await this._createEditor( this.domContainer.current!, this._getConfig() );\n\t\t\treturn;\n\t\t}\n\n\t\t/* istanbul ignore next */\n\t\tif ( this.watchdog ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( this.context instanceof ContextWatchdog ) {\n\t\t\tthis.watchdog = new EditorWatchdogAdapter( this.context );\n\t\t} else {\n\t\t\tthis.watchdog = new CKEditor._EditorWatchdog( this.props.editor, this.props.watchdogConfig );\n\t\t}\n\n\t\tthis.watchdog.setCreator( ( el, config ) => this._createEditor( el as any, config ) );\n\n\t\tthis.watchdog.on( 'error', ( _, { error, causesRestart } ) => {\n\t\t\tconst onError = this.props.onError || console.error;\n\t\t\tonError( error, { phase: 'runtime', willEditorRestart: causesRestart } );\n\t\t} );\n\n\t\tawait this.watchdog\n\t\t\t.create( this.domContainer.current!, this._getConfig() )\n\t\t\t.catch( error => {\n\t\t\t\tconst onError = this.props.onError || console.error;\n\t\t\t\tonError( error, { phase: 'initialization', willEditorRestart: false } );\n\t\t\t} );\n\t}\n\n\t/**\n\t * Creates an editor from the element and configuration.\n\t *\n\t * @param element The source element.\n\t * @param config CKEditor 5 editor configuration.\n\t */\n\tprivate _createEditor( element: HTMLElement | string | Record<string, string>, config: EditorConfig ): Promise<TEditor> {\n\t\treturn this.props.editor.create( element as HTMLElement, config )\n\t\t\t.then( editor => {\n\t\t\t\tif ( 'disabled' in this.props ) {\n\t\t\t\t\t// Switch to the read-only mode if the `[disabled]` attribute is specified.\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\tif ( this.props.disabled ) {\n\t\t\t\t\t\teditor.enableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst modelDocument = editor.model.document;\n\t\t\t\tconst viewDocument = editor.editing.view.document;\n\n\t\t\t\tmodelDocument.on<DocumentChangeEvent>( 'change:data', event => {\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\tif ( this.props.onChange ) {\n\t\t\t\t\t\tthis.props.onChange( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tviewDocument.on( 'focus', event => {\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\tif ( this.props.onFocus ) {\n\t\t\t\t\t\tthis.props.onFocus( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tviewDocument.on( 'blur', event => {\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\tif ( this.props.onBlur ) {\n\t\t\t\t\t\tthis.props.onBlur( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\t// The `onReady` callback should be fired once the `editor` property\n\t\t\t\t// can be reached from the `<CKEditor>` component.\n\t\t\t\t// Ideally this part should be moved to the watchdog item creator listeners.\n\t\t\t\tsetTimeout( () => {\n\t\t\t\t\tif ( this.props.onReady ) {\n\t\t\t\t\t\tthis.props.onReady( editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\treturn editor;\n\t\t\t} );\n\t}\n\n\t/**\n\t * Destroys the editor by destroying the watchdog.\n\t */\n\tprivate async _destroyEditor(): Promise<void> {\n\t\tthis.editorDestructionInProgress = new Promise<void>( resolve => {\n\t\t\t// It may happen during the tests that the watchdog instance is not assigned before destroying itself. See: #197.\n\t\t\t//\n\t\t\t// Additionally, we need to find a way to detect if the whole context has been destroyed. As `componentWillUnmount()`\n\t\t\t// could be fired by <CKEditorContext /> and <CKEditor /> at the same time, this `setTimeout()` makes sure\n\t\t\t// that <CKEditorContext /> component will be destroyed first, so during the code execution\n\t\t\t// the `ContextWatchdog#state` would have a correct value. See `EditorWatchdogAdapter#destroy()` for more information.\n\t\t\t/* istanbul ignore next */\n\t\t\tsetTimeout( async () => {\n\t\t\t\tif ( this.watchdog ) {\n\t\t\t\t\tawait this.watchdog.destroy();\n\t\t\t\t\tthis.watchdog = null;\n\t\t\t\t\treturn resolve();\n\t\t\t\t}\n\n\t\t\t\tif ( this.instance ) {\n\t\t\t\t\tawait this.instance.destroy();\n\t\t\t\t\tthis.instance = null;\n\t\t\t\t\treturn resolve();\n\t\t\t\t}\n\n\t\t\t\tresolve();\n\t\t\t} );\n\t\t} );\n\t}\n\n\t/**\n\t * Returns true when the editor should be updated.\n\t *\n\t * @param nextProps React's properties.\n\t */\n\tprivate _shouldUpdateEditor( nextProps: Readonly<Props<TEditor>> ): boolean {\n\t\t// Check whether `nextProps.data` is equal to `this.props.data` is required if somebody defined the `#data`\n\t\t// property as a static string and updated a state of component when the editor's content has been changed.\n\t\t// If we avoid checking those properties, the editor's content will back to the initial value because\n\t\t// the state has been changed and React will call this method.\n\t\tif ( this.props.data === nextProps.data ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// We should not change data if the editor's content is equal to the `#data` property.\n\t\tif ( this.editor!.data.get() === nextProps.data ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns the editor configuration.\n\t */\n\tprivate _getConfig(): EditorConfig {\n\t\tconst config = this.props.config || {};\n\n\t\tif ( this.props.data && config.initialData ) {\n\t\t\tconsole.warn(\n\t\t\t\t'Editor data should be provided either using `config.initialData` or `content` property. ' +\n\t\t\t\t'The config value takes precedence over `content` property and will be used when both are specified.'\n\t\t\t);\n\t\t}\n\n\t\t// Merge two possible ways of providing data into the `config.initialData` field.\n\t\treturn {\n\t\t\t...config,\n\t\t\tinitialData: config.initialData || this.props.data || ''\n\t\t};\n\t}\n\n\tpublic static override contextType = ContextWatchdogContext;\n\n\t// Properties definition.\n\tpublic static propTypes = {\n\t\teditor: PropTypes.func.isRequired as unknown as Validator<{ create( ...args: any ): Promise<any> }>,\n\t\tdata: PropTypes.string,\n\t\tconfig: PropTypes.object,\n\t\tdisableWatchdog: PropTypes.bool,\n\t\twatchdogConfig: PropTypes.object,\n\t\tonChange: PropTypes.func,\n\t\tonReady: PropTypes.func,\n\t\tonFocus: PropTypes.func,\n\t\tonBlur: PropTypes.func,\n\t\tonError: PropTypes.func,\n\t\tdisabled: PropTypes.bool,\n\t\tid: PropTypes.any\n\t};\n\n\t// Store the API in the static property to easily overwrite it in tests.\n\t// Too bad dependency injection does not work in Webpack + ES 6 (const) + Babel.\n\tpublic static _EditorWatchdog = EditorWatchdog;\n}\n\n/**\n * TODO this is type space definition for props, the CKEditor.propTypes is a run-time props validation that should match.\n */\ninterface Props<TEditor extends Editor> extends InferProps<typeof CKEditor.propTypes> {\n\teditor: { create( ...args: any ): Promise<TEditor> };\n\tconfig?: EditorConfig;\n\twatchdogConfig?: WatchdogConfig;\n\tdisableWatchdog?: boolean;\n\tonReady?: ( editor: TEditor ) => void;\n\tonError?: ( error: Error, details: ErrorDetails ) => void;\n\tonChange?: ( event: EventInfo, editor: TEditor ) => void;\n\tonFocus?: ( event: EventInfo, editor: TEditor ) => void;\n\tonBlur?: ( event: EventInfo, editor: TEditor ) => void;\n}\n\ninterface ErrorDetails {\n\tphase: 'initialization' | 'runtime';\n\twillEditorRestart?: boolean;\n}\n\n/**\n * An adapter aligning the context watchdog API to the editor watchdog API for easier usage.\n */\nexport class EditorWatchdogAdapter<TEditor extends Editor> {\n\t/**\n\t * The context watchdog instance that will be wrapped into editor watchdog API.\n\t */\n\tprivate readonly _contextWatchdog: ContextWatchdog;\n\n\t/**\n\t * A unique id for the adapter to distinguish editor items when using the context watchdog API.\n\t */\n\tprivate readonly _id: string;\n\n\t/**\n\t * A watchdog's editor creator function.\n\t */\n\tprivate _creator?: EditorCreatorFunction;\n\n\t/**\n\t * @param contextWatchdog The context watchdog instance that will be wrapped into editor watchdog API.\n\t */\n\tconstructor( contextWatchdog: ContextWatchdog ) {\n\t\tthis._contextWatchdog = contextWatchdog;\n\t\tthis._id = uid();\n\t}\n\n\t/**\n\t *  @param creator A watchdog's editor creator function.\n\t */\n\tpublic setCreator( creator: EditorCreatorFunction ): void {\n\t\tthis._creator = creator;\n\t}\n\n\t/**\n\t * Adds an editor configuration to the context watchdog registry. Creates an instance of it.\n\t *\n\t * @param sourceElementOrData A source element or data for the new editor.\n\t * @param config CKEditor 5 editor config.\n\t */\n\tpublic create( sourceElementOrData: HTMLElement | string, config: EditorConfig ): Promise<unknown> {\n\t\treturn this._contextWatchdog.add( {\n\t\t\tsourceElementOrData,\n\t\t\tconfig,\n\t\t\tcreator: this._creator!,\n\t\t\tid: this._id,\n\t\t\ttype: 'editor'\n\t\t} );\n\t}\n\n\t/**\n\t * Creates a listener that is attached to context watchdog's item and run when the context watchdog fires.\n\t * Currently works only for the `error` event.\n\t */\n\tpublic on( _: string, callback: ( _: null, data: { error: Error; causesRestart?: boolean } ) => void ): void {\n\t\t// Assume that the event name was error.\n\t\tthis._contextWatchdog.on( 'itemError', ( _, { itemId, error } ) => {\n\t\t\tif ( itemId === this._id ) {\n\t\t\t\tcallback( null, { error, causesRestart: undefined } );\n\t\t\t}\n\t\t} );\n\t}\n\n\tpublic destroy(): Promise<unknown> {\n\t\t// Destroying an editor instance after destroying the Context is handled in the `ContextWatchdog` class.\n\t\t// As `EditorWatchdogAdapter` is an adapter, we should not destroy the editor manually.\n\t\t// Otherwise, it causes that the editor is destroyed twice. However, there is a case, when the editor\n\t\t// needs to be removed from the context, without destroying the context itself. We may assume the following\n\t\t// relations with `ContextWatchdog#state`:\n\t\t//\n\t\t// a) `ContextWatchdog#state` === 'ready' - context is not destroyed; it's safe to destroy the editor manually.\n\t\t// b) `ContextWatchdog#state` === 'destroyed' - context is destroyed; let `ContextWatchdog` handle the whole process.\n\t\t//\n\t\t// See #354 for more information.\n\t\tif ( this._contextWatchdog.state === 'ready' ) {\n\t\t\treturn this._contextWatchdog.remove( this._id );\n\t\t}\n\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * An editor instance.\n\t */\n\tpublic get editor(): TEditor {\n\t\treturn this._contextWatchdog.getItem( this._id ) as TEditor;\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport React, { useState, useEffect, useRef, type Dispatch, type SetStateAction, useContext, useCallback } from 'react';\n\nimport type { EditorConfig } from '@ckeditor/ckeditor5-core';\nimport type { DocumentChangeEvent, Writer, RootElement } from '@ckeditor/ckeditor5-engine';\n\nimport { ContextWatchdog, EditorWatchdog } from '@ckeditor/ckeditor5-watchdog';\nimport type { WatchdogConfig } from '@ckeditor/ckeditor5-watchdog/src/watchdog';\n\nimport type { AddRootEvent, DetachRootEvent } from '@ckeditor/ckeditor5-editor-multi-root/src/multirooteditor';\nimport type MultiRootEditor from '@ckeditor/ckeditor5-build-multi-root';\nimport type EventInfo from '@ckeditor/ckeditor5-utils/src/eventinfo';\n\nimport { ContextWatchdogContext } from './ckeditorcontext';\nimport { EditorWatchdogAdapter } from './ckeditor';\n\nconst REACT_INTEGRATION_READ_ONLY_LOCK_ID = 'Lock from React integration (@ckeditor/ckeditor5-react)';\n\n/* eslint-disable @typescript-eslint/no-use-before-define */\nconst useMultiRootEditor = ( props: MultiRootHookProps ): MultiRootHookReturns => {\n\tconst watchdog = useRef<EditorWatchdog | EditorWatchdogAdapter<MultiRootEditor> | null>( null );\n\n\tconst editorDestructionInProgress = useRef<Promise<void> | null>( null );\n\n\tconst context = useContext( ContextWatchdogContext );\n\n\t// Current editor instance. It may change if the editor is re-initialized by the Watchdog after an error.\n\tconst [ editor, setEditor ] = useState<MultiRootEditor | null>( null );\n\n\t// Current editor data. An object where each key is a root name and the value is the root content.\n\tconst [ data, setData ] = useState<Record<string, string>>( props.data );\n\n\t// Current roots attributes. An object where each key is a root name and the value is an object with root attributes.\n\tconst [ attributes, setAttributes ] = useState<Record<string, Record<string, unknown>>>( props.rootsAttributes || {} );\n\n\t// Contains the JSX elements for each editor root.\n\tconst [ elements, setElements ] = useState<Array<JSX.Element>>( [] );\n\n\tconst shouldUpdateEditor = useRef<boolean>( true );\n\n\tuseEffect( () => {\n\t\tconst initEditor = async () => {\n\t\t\t// When the component has been remounted it is crucial to wait for removing the old editor\n\t\t\t// and cleaning the old state.\n\t\t\tawait editorDestructionInProgress.current;\n\n\t\t\tif ( props.isLayoutReady !== false ) {\n\t\t\t\tawait _initializeEditor();\n\t\t\t}\n\t\t};\n\n\t\tinitEditor();\n\n\t\treturn () => {\n\t\t\t_destroyEditor().then( () => {\n\t\t\t\teditorDestructionInProgress.current = null;\n\t\t\t} );\n\t\t};\n\t}, [ props.isLayoutReady ] );\n\n\tuseEffect( () => {\n\t\tif ( editor ) {\n\t\t\tif ( props.disabled ) {\n\t\t\t\teditor.enableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t} else {\n\t\t\t\teditor.disableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t}\n\t\t}\n\t}, [ props.disabled ] );\n\n\tuseEffect( () => {\n\t\t// When the component has been remounted, keeping the old state, it is important to avoid\n\t\t// updating the editor, which will be destroyed by the unmount callback.\n\t\tif ( editor && !editorDestructionInProgress.current ) {\n\t\t\tconst editorData = editor.getFullData();\n\n\t\t\tsetData( { ...editorData } );\n\t\t\tsetAttributes( { ...editor.getRootsAttributes() } );\n\t\t\tsetElements( [\n\t\t\t\t...Object.keys( editorData ).map( rootName => _createEditableElement( editor, rootName ) )\n\t\t\t] );\n\t\t}\n\t}, [ editor && editor.id ] );\n\n\t/**\n\t * Returns the editor configuration.\n\t */\n\tconst _getConfig = (): EditorConfig => {\n\t\tconst config = props.config || {};\n\n\t\tif ( props.data && config.initialData ) {\n\t\t\tconsole.warn(\n\t\t\t\t'Editor data should be provided either using `config.initialData` or `data` property. ' +\n\t\t\t\t'The config value takes precedence over `data` property and will be used when both are specified.'\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\t...config,\n\t\t\trootsAttributes: attributes\n\t\t};\n\t};\n\n\t/**\n\t * Callback function for handling changed data and attributes in the editor.\n\t */\n\tconst onChangeData = ( editor: MultiRootEditor, event: EventInfo ): void => {\n\t\tconst modelDocument = editor!.model.document;\n\n\t\tif ( !props.disableTwoWayDataBinding ) {\n\t\t\tconst newData: Record<string, string> = {};\n\t\t\tconst newAttributes: Record<string, Record<string, unknown>> = {};\n\n\t\t\tmodelDocument.differ.getChanges()\n\t\t\t\t.forEach( change => {\n\t\t\t\t\tlet root: RootElement;\n\n\t\t\t\t\tif ( change.type == 'insert' || change.type == 'remove' ) {\n\t\t\t\t\t\troot = change.position.root as RootElement;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Must be `attribute` diff item.\n\t\t\t\t\t\troot = change.range.root as RootElement;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Getting data from a not attached root will trigger a warning.\n\t\t\t\t\t// There is another callback for handling detached roots.\n\t\t\t\t\tif ( !root.isAttached() ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { rootName } = root;\n\n\t\t\t\t\tnewData[ rootName ] = editor!.getData( { rootName } );\n\t\t\t\t} );\n\n\t\t\tmodelDocument.differ.getChangedRoots()\n\t\t\t\t.forEach( changedRoot => {\n\t\t\t\t\t// Ignore added and removed roots. They are handled by a different function.\n\t\t\t\t\t// Only register if roots attributes changed.\n\t\t\t\t\tif ( changedRoot.state ) {\n\t\t\t\t\t\tif ( newData[ changedRoot.name ] !== undefined ) {\n\t\t\t\t\t\t\tdelete newData[ changedRoot.name ];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rootName = changedRoot.name;\n\n\t\t\t\t\tnewAttributes[ rootName ] = editor!.getRootAttributes( rootName );\n\t\t\t\t} );\n\n\t\t\tif ( Object.keys( newData ).length ) {\n\t\t\t\tsetData( previousData => ( { ...previousData, ...newData } ) );\n\t\t\t}\n\n\t\t\tif ( Object.keys( newAttributes ).length ) {\n\t\t\t\tsetAttributes( previousAttributes => ( { ...previousAttributes, ...newAttributes } ) );\n\t\t\t}\n\t\t}\n\n\t\t/* istanbul ignore else */\n\t\tif ( props.onChange ) {\n\t\t\tprops.onChange( event, editor! );\n\t\t}\n\t};\n\n\t/**\n\t * Callback function for handling an added root.\n\t */\n\tconst onAddRoot = ( editor: MultiRootEditor, evt: EventInfo, root: RootElement ): void => {\n\t\tconst rootName = root.rootName;\n\n\t\tconst reactElement = _createEditableElement( editor, rootName );\n\n\t\tif ( !props.disableTwoWayDataBinding ) {\n\t\t\tsetData( previousData =>\n\t\t\t\t( { ...previousData, [ rootName ]: editor!.getData( { rootName } ) } )\n\t\t\t);\n\n\t\t\tsetAttributes( previousAttributes =>\n\t\t\t\t( { ...previousAttributes, [ rootName ]: editor!.getRootAttributes( rootName ) } )\n\t\t\t);\n\t\t}\n\n\t\tsetElements( previousElements => [ ...previousElements, reactElement ] );\n\t};\n\n\t/**\n\t * Callback function for handling a detached root.\n\t */\n\tconst onDetachRoot = ( editor: MultiRootEditor, evt: EventInfo, root: RootElement ): void => {\n\t\tconst rootName = root.rootName;\n\n\t\tsetElements( previousElements => previousElements.filter( element => element.props.id !== rootName ) );\n\n\t\tif ( !props.disableTwoWayDataBinding ) {\n\t\t\tsetData( previousData => {\n\t\t\t\tconst { [ rootName! ]: _, ...newData } = previousData;\n\n\t\t\t\treturn { ...newData };\n\t\t\t} );\n\n\t\t\tsetAttributes( previousAttributes => {\n\t\t\t\tconst { [ rootName! ]: _, ...newAttributes } = previousAttributes;\n\n\t\t\t\treturn { ...newAttributes };\n\t\t\t} );\n\t\t}\n\n\t\teditor!.detachEditable( root );\n\t};\n\n\t/**\n\t * Creates a React element on which the root editable element is initialized.\n\t */\n\tconst _createEditableElement = ( editor: MultiRootEditor, rootName: string ): JSX.Element => (\n\t\t<div\n\t\t\tid={rootName}\n\t\t\tkey={rootName}\n\t\t\tref={ el => {\n\t\t\t\tif ( el ) {\n\t\t\t\t\tconst editable = editor.ui.view.createEditable( rootName, el );\n\n\t\t\t\t\teditor.ui.addEditable( editable );\n\n\t\t\t\t\teditor.editing.view.forceRender();\n\t\t\t\t}\n\t\t\t}}\n\t\t></div>\n\t);\n\n\t/**\n\t * Creates an editor using initial elements or data, and configuration.\n\t *\n\t * @param initialData The initial data.\n\t * @param config CKEditor 5 editor configuration.\n\t */\n\tconst _createEditor = (\n\t\tinitialData: Record<string, string> | Record<string, HTMLElement>,\n\t\tconfig: EditorConfig\n\t): Promise<MultiRootEditor> => {\n\t\treturn props.editor.create( initialData, config )\n\t\t\t.then( ( editor: MultiRootEditor ) => {\n\t\t\t\tif ( props.disabled ) {\n\t\t\t\t\t// Switch to the read-only mode if the `[disabled]` attribute is specified.\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\tif ( props.disabled ) {\n\t\t\t\t\t\teditor.enableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst modelDocument = editor.model.document;\n\t\t\t\tconst viewDocument = editor.editing.view.document;\n\n\t\t\t\tmodelDocument.on<DocumentChangeEvent>( 'change:data', evt => onChangeData( editor, evt ) );\n\n\t\t\t\teditor.on<AddRootEvent>( 'addRoot', ( evt, root ) => onAddRoot( editor, evt, root ) );\n\t\t\t\teditor.on<DetachRootEvent>( 'detachRoot', ( evt, root ) => onDetachRoot( editor, evt, root ) );\n\n\t\t\t\tviewDocument.on( 'focus', event => {\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\tif ( props.onFocus ) {\n\t\t\t\t\t\tprops.onFocus( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tviewDocument.on( 'blur', event => {\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\tif ( props.onBlur ) {\n\t\t\t\t\t\tprops.onBlur( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tsetEditor( editor );\n\n\t\t\t\tif ( props.onReady ) {\n\t\t\t\t\tprops.onReady( editor );\n\t\t\t\t}\n\n\t\t\t\treturn editor;\n\t\t\t} );\n\t};\n\n\t/**\n\t * Destroys the editor by destroying the watchdog.\n\t */\n\tconst _destroyEditor = async (): Promise<void> => {\n\t\tsetEditor( null );\n\t\tsetData( {} );\n\t\tsetAttributes( {} );\n\t\tsetElements( [] );\n\n\t\teditorDestructionInProgress.current = new Promise<void>( resolve => {\n\t\t\t// It may happen during the tests that the watchdog instance is not assigned before destroying itself. See: #197.\n\t\t\t//\n\t\t\t// Additionally, we need to find a way to detect if the whole context has been destroyed. As `componentWillUnmount()`\n\t\t\t// could be fired by <CKEditorContext /> and <CKEditor /> at the same time, this `setTimeout()` makes sure\n\t\t\t// that <CKEditorContext /> component will be destroyed first, so during the code execution\n\t\t\t// the `ContextWatchdog#state` would have a correct value. See `EditorWatchdogAdapter#destroy()` for more information.\n\t\t\t/* istanbul ignore next */\n\t\t\tsetTimeout( async () => {\n\t\t\t\tif ( watchdog.current ) {\n\t\t\t\t\tawait watchdog.current.destroy();\n\t\t\t\t\twatchdog.current = null;\n\n\t\t\t\t\treturn resolve();\n\t\t\t\t}\n\n\t\t\t\tif ( editor ) {\n\t\t\t\t\tawait editor.destroy();\n\n\t\t\t\t\treturn resolve();\n\t\t\t\t}\n\n\t\t\t\tresolve();\n\t\t\t} );\n\t\t} );\n\t};\n\n\t/**\n\t * Initializes the editor by creating a proper watchdog and initializing it with the editor's configuration.\n\t */\n\tconst _initializeEditor = async (): Promise<void> => {\n\t\tif ( props.disableWatchdog ) {\n\t\t\tawait _createEditor( props.data, _getConfig() );\n\n\t\t\treturn;\n\t\t}\n\n\t\t/* istanbul ignore next */\n\t\tif ( watchdog.current ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( context instanceof ContextWatchdog ) {\n\t\t\twatchdog.current = new EditorWatchdogAdapter( context );\n\t\t} else {\n\t\t\twatchdog.current = new EditorWatchdog( props.editor, props.watchdogConfig );\n\t\t}\n\n\t\tconst watchdogInstance = watchdog.current;\n\n\t\twatchdogInstance.setCreator( ( data, config ) => _createEditor( data as Record<string, string>, config ) );\n\n\t\twatchdogInstance.on( 'error', ( _, { error, causesRestart } ) => {\n\t\t\tconst onError = props.onError || console.error;\n\n\t\t\tonError( error, { phase: 'runtime', willEditorRestart: causesRestart } );\n\t\t} );\n\n\t\tawait watchdogInstance\n\t\t\t.create( data as any, _getConfig() )\n\t\t\t.catch( error => {\n\t\t\t\tconst onError = props.onError || console.error;\n\n\t\t\t\tonError( error, { phase: 'initialization', willEditorRestart: false } );\n\t\t\t} );\n\t};\n\n\tuseEffect( () => {\n\t\tif ( !editor ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Editor should be only updated when the changes come from the integrator React application.\n\t\tif ( shouldUpdateEditor.current ) {\n\t\t\tshouldUpdateEditor.current = false;\n\n\t\t\tconst dataKeys = Object.keys( data );\n\t\t\tconst attributesKeys = Object.keys( attributes );\n\n\t\t\t// Check if `data` and `attributes` have the same keys.\n\t\t\t//\n\t\t\t// It prevents the addition of attributes for non-existing roots.\n\t\t\t// If the `data` object has a different set of keys, an error will not be thrown\n\t\t\t// since the attributes will be removed/added during root initialization/destruction.\n\t\t\tif ( !dataKeys.every( key => attributesKeys.includes( key ) ) ) {\n\t\t\t\tthrow new Error( '`data` and `attributes` objects must have the same keys (roots).' );\n\t\t\t}\n\n\t\t\tconst editorData = editor.getFullData();\n\t\t\tconst editorAttributes = editor.getRootsAttributes();\n\n\t\t\tconst {\n\t\t\t\taddedKeys: newRoots,\n\t\t\t\tremovedKeys: removedRoots\n\t\t\t} = _getStateDiff( editorData, data || {} );\n\n\t\t\tconst hasModifiedData = dataKeys.some( rootName =>\n\t\t\t\teditorData[ rootName ] !== undefined &&\n\t\t\t\tJSON.stringify( editorData[ rootName ] ) !== JSON.stringify( data[ rootName ] )\n\t\t\t);\n\n\t\t\tconst rootsWithChangedAttributes = attributesKeys.filter( rootName =>\n\t\t\t\tJSON.stringify( editorAttributes[ rootName ] ) !== JSON.stringify( attributes[ rootName ] ) );\n\n\t\t\teditor.model.change( writer => {\n\t\t\t\t_handleNewRoots( newRoots );\n\t\t\t\t_handleRemovedRoots( removedRoots );\n\n\t\t\t\tif ( hasModifiedData ) {\n\t\t\t\t\t_updateEditorData();\n\t\t\t\t}\n\n\t\t\t\tif ( rootsWithChangedAttributes.length ) {\n\t\t\t\t\t_updateEditorAttributes( writer, rootsWithChangedAttributes );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t}, [ data, attributes ] );\n\n\tconst _getStateDiff = (\n\t\tpreviousState: Record<string, unknown>,\n\t\tnewState: Record<string, unknown>\n\t): {\n\t\taddedKeys: Array<string>;\n\t\tremovedKeys: Array<string>;\n\t} => {\n\t\tconst previousStateKeys = Object.keys( previousState );\n\t\tconst newStateKeys = Object.keys( newState );\n\n\t\treturn {\n\t\t\taddedKeys: newStateKeys.filter( key => !previousStateKeys.includes( key ) ),\n\t\t\tremovedKeys: previousStateKeys.filter( key => !newStateKeys.includes( key ) )\n\t\t};\n\t};\n\n\tconst _handleNewRoots = ( roots: Array<string> ) => {\n\t\troots.forEach( rootName => {\n\t\t\teditor!.addRoot( rootName, {\n\t\t\t\tdata: data[ rootName ] || '',\n\t\t\t\tattributes: attributes?.[ rootName ] || {},\n\t\t\t\tisUndoable: true\n\t\t\t} );\n\t\t} );\n\t};\n\n\tconst _handleRemovedRoots = ( roots: Array<string> ) => {\n\t\troots.forEach( rootName => {\n\t\t\teditor!.detachRoot( rootName, true );\n\t\t} );\n\t};\n\n\tconst _updateEditorData = () => {\n\t\t// If any of the roots content has changed, set the editor data.\n\t\t// Unfortunately, we cannot set the editor data just for one root, so we need to overwrite all roots (`nextProps.data` is an\n\t\t// object with data for each root).\n\t\teditor!.data.set( data, { suppressErrorInCollaboration: true } as any );\n\t};\n\n\tconst _updateEditorAttributes = ( writer: Writer, roots: Array<string> ) => {\n\t\troots.forEach( rootName => {\n\t\t\tObject.keys( attributes![ rootName ] ).forEach( attr => {\n\t\t\t\teditor!.registerRootAttribute( attr );\n\t\t\t} );\n\n\t\t\twriter.clearAttributes( editor!.model.document.getRoot( rootName )! );\n\t\t\twriter.setAttributes( attributes![ rootName ], editor!.model.document.getRoot( rootName )! );\n\t\t} );\n\t};\n\n\tconst _externalSetData: Dispatch<SetStateAction<Record<string, string>>> = useCallback(\n\t\tnewData => {\n\t\t\tshouldUpdateEditor.current = true;\n\t\t\tsetData( newData );\n\t\t},\n\t\t[ setData ]\n\t);\n\n\tconst _externalSetAttributes: Dispatch<SetStateAction<Record<string, Record<string, unknown>>>> = useCallback(\n\t\tnewAttributes => {\n\t\t\tshouldUpdateEditor.current = true;\n\t\t\tsetAttributes( newAttributes );\n\t\t},\n\t\t[ setAttributes ]\n\t);\n\n\treturn {\n\t\teditor, editableElements: elements, toolbarElement: <EditorToolbarWrapper editor={editor} />,\n\t\tdata, setData: _externalSetData,\n\t\tattributes, setAttributes: _externalSetAttributes\n\t};\n};\n\nconst EditorToolbarWrapper = ( { editor }: any ) => {\n\tconst toolbarRef = useRef<HTMLDivElement>( null );\n\n\tuseEffect( () => {\n\t\tconst toolbarContainer = toolbarRef.current;\n\n\t\tif ( !editor || !toolbarContainer ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst element = editor.ui.view.toolbar.element!;\n\n\t\tif ( toolbarContainer ) {\n\t\t\ttoolbarContainer.appendChild( element! );\n\t\t}\n\n\t\treturn () => {\n\t\t\tif ( toolbarContainer ) {\n\t\t\t\ttoolbarContainer.removeChild( element! );\n\t\t\t}\n\t\t};\n\t}, [ editor && editor.id ] );\n\n\treturn <div ref={toolbarRef}></div>;\n};\n\nexport default useMultiRootEditor;\n\ninterface ErrorDetails {\n\tphase: 'initialization' | 'runtime';\n\twillEditorRestart?: boolean;\n}\n\nexport type MultiRootHookProps = {\n\tisLayoutReady?: boolean;\n\tdisabled?: boolean;\n\tdata: Record<string, string>;\n\trootsAttributes?: Record<string, Record<string, unknown>>;\n\teditor: typeof MultiRootEditor;\n\twatchdogConfig?: WatchdogConfig;\n\tdisableWatchdog?: boolean;\n\tdisableTwoWayDataBinding?: boolean;\n\n\tonReady?: ( editor: MultiRootEditor ) => void;\n\tonError?: ( error: Error, details: ErrorDetails ) => void;\n\tonChange?: ( event: EventInfo, editor: MultiRootEditor ) => void;\n\tonFocus?: ( event: EventInfo, editor: MultiRootEditor ) => void;\n\tonBlur?: ( event: EventInfo, editor: MultiRootEditor ) => void;\n\n\tconfig?: Record<string, unknown>;\n};\n\nexport type MultiRootHookReturns = {\n\teditor: MultiRootEditor | null;\n\teditableElements: Array<JSX.Element>;\n\ttoolbarElement: JSX.Element;\n\tdata: Record<string, string>;\n\tsetData: Dispatch<SetStateAction<Record<string, string>>>;\n\tattributes: Record<string, Record<string, unknown>>;\n\tsetAttributes: Dispatch<SetStateAction<Record<string, Record<string, unknown>>>>;\n};\n"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__155__","__WEBPACK_EXTERNAL_MODULE__949__","__WEBPACK_EXTERNAL_MODULE__546__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","HEX_NUMBERS","Array","fill","map","_","index","toString","slice","ContextWatchdogContext","CKEditorContext","constructor","props","context","super","contextWatchdog","this","isLayoutReady","_initializeContextWatchdog","config","shouldComponentUpdate","nextProps","_shouldComponentUpdate","id","destroy","children","render","Provider","componentWillUnmount","_destroyContext","ContextWatchdog","watchdogConfig","on","errorEvent","onError","error","phase","willContextRestart","causesRestart","state","onReady","create","catch","defaultProps","details","console","propTypes","REACT_INTEGRATION_READ_ONLY_LOCK_ID","CKEditor","editorDestructionInProgress","domContainer","watchdog","CKEDITOR_VERSION","window","major","split","Number","warn","editor","disableWatchdog","instance","_shouldUpdateEditor","data","set","disabled","enableReadOnlyMode","disableReadOnlyMode","componentDidMount","_initializeEditor","componentDidUpdate","_destroyEditor","ref","_createEditor","current","_getConfig","EditorWatchdogAdapter","_EditorWatchdog","setCreator","el","willEditorRestart","element","then","modelDocument","model","document","viewDocument","editing","view","event","onChange","onFocus","onBlur","setTimeout","Promise","resolve","async","initialData","contextType","isRequired","EditorWatchdog","_contextWatchdog","_id","r1","Math","random","r2","r3","r4","uid","creator","_creator","sourceElementOrData","add","type","callback","itemId","remove","getItem","EditorToolbarWrapper","toolbarRef","useRef","useEffect","toolbarContainer","ui","toolbar","appendChild","removeChild","useContext","setEditor","useState","setData","attributes","setAttributes","rootsAttributes","elements","setElements","shouldUpdateEditor","initEditor","editorData","getFullData","getRootsAttributes","keys","rootName","_createEditableElement","editable","createEditable","addEditable","forceRender","evt","disableTwoWayDataBinding","newData","newAttributes","differ","getChanges","forEach","change","position","range","isAttached","getData","getChangedRoots","changedRoot","name","getRootAttributes","length","previousData","previousAttributes","onChangeData","reactElement","previousElements","onAddRoot","filter","detachEditable","onDetachRoot","watchdogInstance","dataKeys","attributesKeys","every","includes","Error","editorAttributes","addedKeys","newRoots","removedKeys","removedRoots","_getStateDiff","hasModifiedData","some","JSON","stringify","rootsWithChangedAttributes","writer","_handleNewRoots","_handleRemovedRoots","_updateEditorData","_updateEditorAttributes","previousState","newState","previousStateKeys","newStateKeys","roots","addRoot","isUndoable","detachRoot","suppressErrorInCollaboration","attr","registerRootAttribute","clearAttributes","getRoot","_externalSetData","useCallback","_externalSetAttributes","editableElements","toolbarElement"],"sourceRoot":""}